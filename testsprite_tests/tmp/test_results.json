[
  {
    "projectId": "a11c1acd-7652-4e25-a05d-f1b197fc78ff",
    "testId": "dbd34c66-2604-4b40-a2ab-8d5e754e0731",
    "userId": "d40804a8-1071-7031-87b9-e30ae91b4e4e",
    "title": "TC001-user registration with valid data",
    "description": "Test the user registration endpoint with valid name, email, and password to ensure a new user is created successfully and an access token is returned.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\ndef test_user_registration_with_valid_data():\n    base_url = \"http://localhost:5001\"\n    url = f\"{base_url}/api/auth/register\"\n    auth = HTTPBasicAuth(\"TestUser1\", \"Testing@123\")\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    payload = {\n        \"name\": \"John Doe\",\n        \"email\": \"john.doe@example.com\",\n        \"password\": \"StrongPassw0rd!\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, auth=auth, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 201, f\"Expected status code 201 but got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert \"access_token\" in data and isinstance(data[\"access_token\"], str) and data[\"access_token\"], \"Access token missing or invalid\"\n    assert \"user\" in data and isinstance(data[\"user\"], dict), \"User object missing or invalid\"\n    user = data[\"user\"]\n    assert \"id\" in user and isinstance(user[\"id\"], int), \"User id missing or invalid\"\n    assert user.get(\"name\") == payload[\"name\"], f\"Expected user name '{payload['name']}' but got '{user.get('name')}'\"\n    assert user.get(\"email\") == payload[\"email\"], f\"Expected user email '{payload['email']}' but got '{user.get('email')}'\"\n    assert \"message\" in data and isinstance(data[\"message\"], str), \"Message missing or invalid\"\n\ntest_user_registration_with_valid_data()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T19:30:39.066Z",
    "modified": "2025-09-19T19:30:59.027Z"
  },
  {
    "projectId": "a11c1acd-7652-4e25-a05d-f1b197fc78ff",
    "testId": "bb3a4a72-a7e8-41f9-98b4-266c0516d831",
    "userId": "d40804a8-1071-7031-87b9-e30ae91b4e4e",
    "title": "TC002-user login with valid credentials",
    "description": "Test the user login endpoint with correct email and password to verify successful authentication and receipt of an access token.",
    "code": "import requests\n\ndef test_user_login_with_valid_credentials():\n    base_url = \"http://localhost:5001\"\n    login_endpoint = f\"{base_url}/api/auth/login\"\n    \n    payload = {\n        \"email\": \"testuser1@example.com\",\n        \"password\": \"Testing@123\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        response = requests.post(login_endpoint, json=payload, headers=headers, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not in JSON format\"\n\n    assert \"access_token\" in data, \"Response JSON does not contain access_token\"\n    assert isinstance(data[\"access_token\"], str) and data[\"access_token\"], \"access_token is empty or not a string\"\n\n    user = data.get(\"user\")\n    assert user is not None, \"Response JSON does not contain user object\"\n    assert isinstance(user, dict), \"user field is not an object\"\n    assert \"id\" in user and isinstance(user[\"id\"], int), \"User id missing or not int\"\n    assert \"name\" in user and isinstance(user[\"name\"], str), \"User name missing or not string\"\n    assert \"email\" in user and isinstance(user[\"email\"], str), \"User email missing or not string\"\n    assert user[\"email\"].lower() == payload[\"email\"].lower(), \"User email in response does not match login email\"\n\n    assert \"message\" in data and isinstance(data[\"message\"], str) and data[\"message\"], \"Response message is missing or empty\"\n\ntest_user_login_with_valid_credentials()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T19:30:39.072Z",
    "modified": "2025-09-19T19:31:39.592Z"
  },
  {
    "projectId": "a11c1acd-7652-4e25-a05d-f1b197fc78ff",
    "testId": "0b9d316d-77c9-4b3a-80e2-252f1a392708",
    "userId": "d40804a8-1071-7031-87b9-e30ae91b4e4e",
    "title": "TC003-get tasks with valid token and filters",
    "description": "Test retrieving tasks for an authenticated user with various filters like status, category, priority, and search terms to ensure correct tasks are returned.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nTASKS_URL = f\"{BASE_URL}/api/tasks\"\nTIMEOUT = 30\n\ndef test_get_tasks_with_valid_token_and_filters():\n    # Step 1: Login to get access token\n    login_payload = {\n        \"email\": \"testuser1@example.com\",    # Corrected to a valid email format\n        \"password\": \"Testing@123\"\n    }\n    try:\n        login_response = requests.post(\n            LOGIN_URL,\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_response.status_code == 200, f\"Login failed: {login_response.text}\"\n        login_data = login_response.json()\n        access_token = login_data.get(\"access_token\")\n        assert access_token, \"No access token returned on login\"\n    except Exception as e:\n        assert False, f\"Exception during login: {e}\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n\n    # Define a set of filters to test\n    filters_list = [\n        {\"status\": \"Pending\"},\n        {\"category\": \"Work\"},\n        {\"priority\": \"High\"},\n        {\"search\": \"report\"},\n        {\"status\": \"Completed\", \"category\": \"Home\"},\n        {\"priority\": \"Low\", \"search\": \"shopping\"},\n        {\"status\": \"In Progress\", \"category\": \"Work\", \"priority\": \"Medium\", \"search\": \"project\"},\n    ]\n\n    for filters in filters_list:\n        try:\n            response = requests.get(\n                TASKS_URL,\n                headers=headers,\n                params=filters,\n                timeout=TIMEOUT\n            )\n            assert response.status_code == 200, f\"Failed to get tasks with filters {filters}: {response.status_code} - {response.text}\"\n\n            data = response.json()\n            tasks = data.get(\"tasks\")\n            assert isinstance(tasks, list), f\"Tasks is not a list with filters {filters}\"\n\n            # If tasks returned, validate that each task meets filter criteria if possible\n            for task in tasks:\n                # Validate type and essential fields presence\n                assert \"id\" in task and isinstance(task[\"id\"], int)\n                assert \"title\" in task and isinstance(task[\"title\"], str)\n                assert \"status\" in task and isinstance(task[\"status\"], str)\n                assert \"category\" in task and isinstance(task[\"category\"], str)\n                assert \"priority\" in task and isinstance(task[\"priority\"], str)\n                assert \"description\" in task and isinstance(task[\"description\"], str)\n                assert \"tags\" in task and isinstance(task[\"tags\"], list)\n\n                # Check filters match if filter is set and value present\n                if \"status\" in filters:\n                    assert filters[\"status\"].lower() == task[\"status\"].lower(), f\"Status filter mismatch: expected {filters['status']} got {task['status']}\"\n                if \"category\" in filters:\n                    assert filters[\"category\"].lower() == task[\"category\"].lower(), f\"Category filter mismatch: expected {filters['category']} got {task['category']}\"\n                if \"priority\" in filters:\n                    assert filters[\"priority\"].lower() == task[\"priority\"].lower(), f\"Priority filter mismatch: expected {filters['priority']} got {task['priority']}\"\n                if \"search\" in filters:\n                    # Search should match either title or description (case insensitive)\n                    search_term = filters[\"search\"].lower()\n                    title = task[\"title\"].lower()\n                    description = task[\"description\"].lower()\n                    assert search_term in title or search_term in description, f\"Search term '{filters['search']}' not found in title or description\"\n        except Exception as e:\n            assert False, f\"Exception fetching tasks with filters {filters}: {e}\"\n\ntest_get_tasks_with_valid_token_and_filters()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T19:30:39.077Z",
    "modified": "2025-09-19T19:31:51.145Z"
  },
  {
    "projectId": "a11c1acd-7652-4e25-a05d-f1b197fc78ff",
    "testId": "0435167c-bdf1-4413-9bb3-d143ea09439c",
    "userId": "d40804a8-1071-7031-87b9-e30ae91b4e4e",
    "title": "TC004-create task with required and optional fields",
    "description": "Test creating a new task with mandatory title and optional fields such as description, due date, priority, status, category, and tags to verify task creation.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:5001\"\n\nUSERNAME = \"testuser1@example.com\"\nPASSWORD = \"Testing@123\"\n\ndef test_create_task_with_required_and_optional_fields():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    tasks_url = f\"{BASE_URL}/api/tasks\"\n    timeout = 30\n\n    # Step 1: Authenticate to get access token\n    try:\n        login_payload = {\n            \"email\": USERNAME,\n            \"password\": PASSWORD\n        }\n        login_resp = requests.post(login_url, json=login_payload, timeout=timeout)\n        assert login_resp.status_code == 200, f\"Login failed with status code {login_resp.status_code}\"\n        login_data = login_resp.json()\n        access_token = login_data.get(\"access_token\")\n        assert access_token, \"No access token returned on login\"\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Authentication failed: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Prepare task data with mandatory and optional fields\n    due_date_iso = (datetime.utcnow() + timedelta(days=7)).replace(microsecond=0).isoformat() + \"Z\"\n\n    task_payload = {\n        \"title\": \"Test Task with optional fields\",\n        \"description\": \"This is a test task including optional fields\",\n        \"due_date\": due_date_iso,\n        \"priority\": \"High\",\n        \"status\": \"Pending\",\n        \"category\": \"Testing\",\n        \"tags\": [\"unit-test\", \"automation\"]\n    }\n\n    task_id = None\n    try:\n        # Step 2: Create task request\n        create_resp = requests.post(tasks_url, headers=headers, json=task_payload, timeout=timeout)\n        assert create_resp.status_code == 201, f\"Create task failed with status code {create_resp.status_code}\"\n        create_data = create_resp.json()\n\n        # Step 3: Validate response content\n        assert \"message\" in create_data and isinstance(create_data[\"message\"], str), \"Response missing message field\"\n        task = create_data.get(\"task\")\n        assert task and isinstance(task, dict), \"Response missing task data\"\n\n        # Validate mandatory title\n        assert task.get(\"title\") == task_payload[\"title\"], \"Task title does not match payload\"\n\n        # Validate optional fields\n        assert task.get(\"description\") == task_payload[\"description\"], \"Task description mismatch\"\n        # Due date - allow slight formatting differences, parse and compare\n        returned_due_date = task.get(\"due_date\")\n        assert returned_due_date is not None, \"Task due_date missing\"\n        # We'll just check that returned_due_date starts with the same date as sent (date+time)\n        assert returned_due_date.startswith(due_date_iso[:19]), \"Task due_date mismatch\"\n\n        assert task.get(\"priority\") == task_payload[\"priority\"], \"Task priority mismatch\"\n        assert task.get(\"status\") == task_payload[\"status\"], \"Task status mismatch\"\n        assert task.get(\"category\") == task_payload[\"category\"], \"Task category mismatch\"\n        assert task.get(\"tags\") == task_payload[\"tags\"], \"Task tags mismatch\"\n\n        # Validate presence of created_at and updated_at fields\n        assert \"created_at\" in task and isinstance(task[\"created_at\"], str), \"Missing created_at\"\n        assert \"updated_at\" in task and isinstance(task[\"updated_at\"], str), \"Missing updated_at\"\n\n        task_id = task.get(\"id\")\n        assert isinstance(task_id, int), \"Task ID missing or invalid\"\n\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Create task test failed: {e}\")\n\n    finally:\n        # Cleanup - delete the created task\n        if task_id is not None:\n            try:\n                delete_resp = requests.delete(f\"{tasks_url}/{task_id}\", headers=headers, timeout=timeout)\n                assert delete_resp.status_code == 200, f\"Cleanup delete task failed with status code {delete_resp.status_code}\"\n            except requests.RequestException:\n                pass  # Ignore cleanup errors\n\n\ntest_create_task_with_required_and_optional_fields()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T19:30:39.084Z",
    "modified": "2025-09-19T19:31:30.708Z"
  },
  {
    "projectId": "a11c1acd-7652-4e25-a05d-f1b197fc78ff",
    "testId": "db2abbf5-fda2-4381-bdcf-8c64a3be1738",
    "userId": "d40804a8-1071-7031-87b9-e30ae91b4e4e",
    "title": "TC005-update existing task with valid data",
    "description": "Test updating an existing task by task ID with valid fields to confirm the task is updated correctly and the response contains updated task details.",
    "code": "import requests\nfrom datetime import datetime\n\nBASE_URL = \"http://localhost:5001\"\nEMAIL = \"testuser1@example.com\"\nPASSWORD = \"Testing@123\"\nTIMEOUT = 30\n\ndef parse_datetime(dt_str):\n    # Try parsing the date-time string in known ISO formats\n    for fmt in (\"%Y-%m-%dT%H:%M:%SZ\", \"%Y-%m-%dT%H:%M:%S.%fZ\", \"%Y-%m-%dT%H:%M:%S%z\", \"%Y-%m-%dT%H:%M:%S.%f%z\"):\n        try:\n            return datetime.strptime(dt_str, fmt)\n        except (ValueError, TypeError):\n            continue\n    # If all fail, raise error\n    raise ValueError(f\"Unknown datetime format: {dt_str}\")\n\ndef test_update_existing_task_with_valid_data():\n    # Login to get access token\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\n        \"email\": EMAIL,\n        \"password\": PASSWORD\n    }\n    try:\n        login_resp = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        access_token = login_data.get(\"access_token\")\n        assert access_token, \"No access token returned on login\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Create a new task to update later\n        create_task_url = f\"{BASE_URL}/api/tasks\"\n        create_payload = {\n            \"title\": \"Initial Title for Update Test\",\n            \"description\": \"Initial description\",\n            \"due_date\": \"2025-12-31T23:59:59Z\",\n            \"priority\": \"Medium\",\n            \"status\": \"Pending\",\n            \"category\": \"Testing\",\n            \"tags\": [\"update\", \"test\"]\n        }\n        create_resp = requests.post(create_task_url, json=create_payload, headers=headers, timeout=TIMEOUT)\n        assert create_resp.status_code == 201, f\"Task creation failed with status {create_resp.status_code}\"\n        create_data = create_resp.json()\n        task = create_data.get(\"task\")\n        assert task, \"No task object in create response\"\n        task_id = task.get(\"id\")\n        assert task_id is not None, \"No task ID returned\"\n\n        # Prepare update payload with valid data\n        update_payload = {\n            \"title\": \"Updated Title for Task\",\n            \"description\": \"Updated description of the task\",\n            \"due_date\": \"2026-01-15T12:00:00Z\",\n            \"priority\": \"High\",\n            \"status\": \"In Progress\",\n            \"category\": \"Updated Testing\",\n            \"tags\": [\"updated\", \"important\"]\n        }\n\n        update_task_url = f\"{BASE_URL}/api/tasks/{task_id}\"\n        update_resp = requests.put(update_task_url, json=update_payload, headers=headers, timeout=TIMEOUT)\n        assert update_resp.status_code == 200, f\"Task update failed with status {update_resp.status_code}\"\n        update_data = update_resp.json()\n\n        # Validate response contains updated task details\n        updated_task = update_data.get(\"task\")\n        assert updated_task, \"No task object in update response\"\n        assert updated_task.get(\"id\") == task_id, \"Updated task ID mismatch\"\n        assert updated_task.get(\"title\") == update_payload[\"title\"], \"Title not updated correctly\"\n        assert updated_task.get(\"description\") == update_payload[\"description\"], \"Description not updated correctly\"\n\n        # Compare due_date via datetime equality\n        expected_due_date = parse_datetime(update_payload[\"due_date\"])\n        actual_due_date = parse_datetime(updated_task.get(\"due_date\"))\n        assert expected_due_date == actual_due_date, \"Due date not updated correctly\"\n\n        assert updated_task.get(\"priority\") == update_payload[\"priority\"], \"Priority not updated correctly\"\n        assert updated_task.get(\"status\") == update_payload[\"status\"], \"Status not updated correctly\"\n        assert updated_task.get(\"category\") == update_payload[\"category\"], \"Category not updated correctly\"\n        assert updated_task.get(\"tags\") == update_payload[\"tags\"], \"Tags not updated correctly\"\n\n    finally:\n        # Cleanup - delete the created task if it exists\n        if 'task_id' in locals() and task_id is not None:\n            delete_url = f\"{BASE_URL}/api/tasks/{task_id}\"\n            try:\n                delete_resp = requests.delete(delete_url, headers={\"Authorization\": f\"Bearer {access_token}\"}, timeout=TIMEOUT)\n                # It's okay if delete fails, just attempt cleanup\n            except Exception:\n                pass\n\n\ntest_update_existing_task_with_valid_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 101, in <module>\n  File \"<string>\", line 82, in test_update_existing_task_with_valid_data\n  File \"<string>\", line 17, in parse_datetime\nValueError: Unknown datetime format: 2026-01-15T12:00:00\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T19:30:39.089Z",
    "modified": "2025-09-19T19:32:04.946Z"
  },
  {
    "projectId": "a11c1acd-7652-4e25-a05d-f1b197fc78ff",
    "testId": "549e37e1-fdd0-4d5c-850c-f929f1efb419",
    "userId": "d40804a8-1071-7031-87b9-e30ae91b4e4e",
    "title": "TC006-delete task by valid task id",
    "description": "Test deleting a task by providing a valid task ID and valid authentication token to ensure the task is removed successfully.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nEMAIL = \"testuser1@example.com\"\nPASSWORD = \"Testing@123\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nCREATE_TASK_URL = f\"{BASE_URL}/api/tasks\"\nDELETE_TASK_URL_TEMPLATE = f\"{BASE_URL}/api/tasks/{{task_id}}\"\nTIMEOUT = 30\n\ndef test_delete_task_by_valid_task_id():\n    # Login to get access token\n    login_payload = {\n        \"email\": EMAIL,\n        \"password\": PASSWORD\n    }\n    try:\n        login_resp = requests.post(\n            LOGIN_URL,\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        login_resp.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n    login_data = login_resp.json()\n    assert \"access_token\" in login_data, \"Access token missing in login response\"\n    access_token = login_data[\"access_token\"]\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Create a task to delete\n    create_task_payload = {\n        \"title\": \"Test Task for Deletion\",\n        \"description\": \"Task created for testing deletion endpoint\",\n        \"priority\": \"Medium\",\n        \"status\": \"Pending\"\n    }\n    try:\n        create_resp = requests.post(\n            CREATE_TASK_URL,\n            json=create_task_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        create_resp.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Create task request failed: {e}\"\n    create_data = create_resp.json()\n    assert \"task\" in create_data, \"Task data missing in create response\"\n    task_id = create_data[\"task\"].get(\"id\")\n    assert isinstance(task_id, int), \"Created task ID is invalid\"\n\n    try:\n        # Delete the task\n        delete_url = DELETE_TASK_URL_TEMPLATE.format(task_id=task_id)\n        try:\n            delete_resp = requests.delete(\n                delete_url,\n                headers=headers,\n                timeout=TIMEOUT\n            )\n        except requests.RequestException as e:\n            assert False, f\"Delete request failed: {e}\"\n\n        assert delete_resp.status_code == 200, f\"Expected status code 200 on delete but got {delete_resp.status_code}\"\n        delete_data = delete_resp.json()\n        assert \"message\" in delete_data, \"Delete response missing message\"\n\n        # Verify the task is actually deleted by trying to delete again or get the task if get endpoint exists\n        # Since get task by id endpoint is not specified, we validate delete by expecting 404 on repeat delete\n        repeat_delete_resp = requests.delete(\n            delete_url,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert repeat_delete_resp.status_code == 404, f\"Expected status code 404 on deleting already deleted task but got {repeat_delete_resp.status_code}\"\n\n    finally:\n        # Cleanup: ensure task is deleted in case test failed before delete\n        delete_url = DELETE_TASK_URL_TEMPLATE.format(task_id=task_id)\n        try:\n            requests.delete(\n                delete_url,\n                headers=headers,\n                timeout=TIMEOUT\n            )\n        except Exception:\n            pass  # Ignore cleanup errors\n\ntest_delete_task_by_valid_task_id()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T19:30:39.097Z",
    "modified": "2025-09-19T19:31:58.645Z"
  },
  {
    "projectId": "a11c1acd-7652-4e25-a05d-f1b197fc78ff",
    "testId": "a218a5aa-adf7-45d0-a266-4979227e634f",
    "userId": "d40804a8-1071-7031-87b9-e30ae91b4e4e",
    "title": "TC007-get user task statistics with valid token",
    "description": "Test retrieving task statistics for an authenticated user to verify the accuracy of total tasks, completed, pending, in-progress, overdue counts, and completion rate.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nAUTH_EMAIL = \"testuser1@example.com\"\nAUTH_PASSWORD = \"Testing@123\"\nTIMEOUT = 30\n\ndef test_get_user_task_statistics_with_valid_token():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    stats_url = f\"{BASE_URL}/api/stats\"\n\n    # Step 1: Authenticate user to get access token\n    login_payload = {\n        \"email\": AUTH_EMAIL,\n        \"password\": AUTH_PASSWORD\n    }\n\n    try:\n        login_response = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n        login_data = login_response.json()\n        assert \"access_token\" in login_data and login_data[\"access_token\"], \"Access token not found in login response\"\n        token = login_data[\"access_token\"]\n\n        # Step 2: Request task statistics with valid token\n        headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n        stats_response = requests.get(stats_url, headers=headers, timeout=TIMEOUT)\n        assert stats_response.status_code == 200, f\"Statistics request failed with status code {stats_response.status_code}\"\n        stats = stats_response.json()\n\n        # Validate response fields exist and are of correct type\n        required_fields = {\n            \"total_tasks\": int,\n            \"completed_tasks\": int,\n            \"pending_tasks\": int,\n            \"in_progress_tasks\": int,\n            \"overdue_tasks\": int,\n            \"completion_rate\": (float, int)  # can be float or integer number type\n        }\n\n        for field, field_type in required_fields.items():\n            assert field in stats, f\"Missing field '{field}' in statistics response\"\n            assert isinstance(stats[field], field_type), f\"Field '{field}' should be type {field_type} but got {type(stats[field])}\"\n\n        # Additional logical checks:\n        total = stats[\"total_tasks\"]\n        completed = stats[\"completed_tasks\"]\n        pending = stats[\"pending_tasks\"]\n        in_progress = stats[\"in_progress_tasks\"]\n        overdue = stats[\"overdue_tasks\"]\n\n        assert total >= 0, \"Total tasks should be non-negative\"\n        assert completed >= 0, \"Completed tasks should be non-negative\"\n        assert pending >= 0, \"Pending tasks should be non-negative\"\n        assert in_progress >= 0, \"In-progress tasks should be non-negative\"\n        assert overdue >= 0, \"Overdue tasks should be non-negative\"\n\n        # completion_rate should be between 0 and 100 if percentage, or 0 to 1 if ratio\n        completion_rate = stats[\"completion_rate\"]\n        assert 0 <= completion_rate <= 100 or 0 <= completion_rate <= 1, \"Completion rate should be between 0 and 1 or 0 and 100\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n\ntest_get_user_task_statistics_with_valid_token()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T19:30:39.105Z",
    "modified": "2025-09-19T19:31:26.073Z"
  },
  {
    "projectId": "a11c1acd-7652-4e25-a05d-f1b197fc78ff",
    "testId": "106f428f-451a-4c2a-b763-2091d20a70d5",
    "userId": "d40804a8-1071-7031-87b9-e30ae91b4e4e",
    "title": "TC008-health check api status",
    "description": "Test the health check endpoint to confirm the API is running and returns a healthy status message.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5001\"\nUSERNAME = \"TestUser1\"\nPASSWORD = \"Testing@123\"\n\ndef test_health_check_api_status():\n    url = f\"{BASE_URL}/api/health\"\n    try:\n        response = requests.get(url, auth=HTTPBasicAuth(USERNAME, PASSWORD), timeout=30)\n        response.raise_for_status()\n        data = response.json()\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        assert \"status\" in data, \"Response JSON missing 'status' field\"\n        assert \"message\" in data, \"Response JSON missing 'message' field\"\n        assert data[\"status\"].lower() == \"healthy\" or data[\"status\"].lower() == \"ok\" or data[\"status\"].lower() == \"healthy\", f\"Unexpected status message: {data['status']}\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request to health check API failed: {e}\"\n\ntest_health_check_api_status()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T19:30:39.110Z",
    "modified": "2025-09-19T19:31:37.960Z"
  }
]
